# Справочник

## Командная строка

```
$ pwd

$ cd ~ // переходим к домашней директории

$ cd .. // переходим на уровень выше

$ cd . // переходим в текущую директорию

$ cd github/open-source-project // переходим через несколько директорий

$ ls // содержимое папки

$ ls -a // содержимое папки + скрытое

$ touch my-new-file.txt // создали файл my-new-file.txt 

$ mkdir new-dir // создали директорию new-dir 

$ mkdir -p dir1/dir-inside/dir-deeper-inside // создали папку dir-deeper-inside в папке dir-inside, которая находится в папке dir1 

$ cp index.html src/
# скопировали index.html в папку src 

$ cp index.html style.css script.js src/

$ mv table.csv ./very-important-files // сначала указываем имя файла, который хотим переместить, потом путь — куда перемещаем 

$ cat myfile.txt // распечатали содержимое файла myfile.txt

$ rm example.txt // удалили файл example.txt из текущей папки 

$ rmdir images // команда удалит папку images из текущей директории, 
               // если папка images пуста 
			   
$ rm -r images // удалили папку images со всем её содержимым из текущей директории 

```

По умолчанию touch и mkdir создают файлы и папки в текущей рабочей директории. Например, если вы находитесь в директории abs, команда touch file.txt создаст файл именно там: abs/file.txt.
Также можно использовать обе команды вместе с символом домашней директории (~) или родительской директории (..). Например, команда mkdir ~/my-git-projects создаст папку my-git-projects внутри домашней директории.
А команда touch ../../file.txt создаст файл file.txt на две папки выше по иерархии. Допустим, если вы находитесь в директории projects/git/hello, команда touch ../../file.txt создаст файл по такому пути: projects/file.txt.

Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (&&).
У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).
Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама.

## Git

```
$ git config --global user.name "User Namovich" // имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email username@yandex.ru // здесь нужно указать свой настоящий email 

$ cat ~/.gitconfig  //Проверить
$ git config --list 

$ git init //оздали репозиторий

$ rm -rf .git //удалили подпапку .git 

$ git status

$ git add todo.txt

$ git add --all //подготовили к сохранению все файлы в репозитории

$ git commit -m 'Мой первый коммит!' 

 $ git log // Просмотреть историю коммитов

```

---

ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
ключ -f (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».

Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение. 

## SSH

Проверка наличия SSH-ключа
Прежде чем генерировать SSH-ключи, убедитесь, что у вас их ещё нет. По умолчанию директория с SSH-ключами находится в домашней директории. Перейдите в неё.
$ cd ~ # перешли в домашнюю директорию пользователя 
Обычно SSH-ключи находятся в директории .ssh/. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды.

$ ls -la .ssh/ # вывели список созданных ключей 
Если папка пустая или её нет, всё в порядке. Если есть файлы с похожими названиями, SSH-ключи уже создавались:
id_dsa.pub;
id_ecdsa.pub;
id_ed25519.pub;
id_rsa.pub.
Если вы не создавали эти файлы, удалите их все.

Для генерации SSH-пары можно использовать программу ssh-keygen. Откройте терминал и введите следующую команду.
 $ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
  
 Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.
 Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519. Ничего страшного: используйте другой алгоритм.
 $ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
  
 После ввода отобразится такое сообщение.
 > Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи
  
Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.
 macOS
 > Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]
  
 Windows
 > Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter]
  
Теперь в указанной директории появится пара ключей.
Программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter.
 > Enter passphrase (empty for no passphrase): [Type a passphrase]
 > Enter same passphrase again: [Type passphrase again]
  
Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите следующую команду.
 ls -a ~/.ssh
  
 На экране должны появиться два файла — один с расширением .pub, другой — без. Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому! 
 Вся последовательность действий в консоли показана на скриншоте ниже.
 
Инструкция по связыванию SSH-ключа и GitHub-аккаунта
После выполнения ssh-keygen в директории ~/.ssh есть два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали). Скопируйте содержимое файла с публичным ключом в буфер обмена.
 macOS
 # скопировать содержимое ключа в буфер обмена:
 $ pbcopy < ~/.ssh/id_rsa.pub
 # для ed25519:
 $ pbcopy < ~/.ssh/id_ed25519.pub
  
 Здесь используется команда pbcopy — она копирует поток данных в буфер обмена. Запись pbcopy < ~/.ssh/id_rsa.pub означает: «Скопируй в буфер обмена всё содержимое файла ~/.ssh/id_rsa.pub». В качестве альтернативы вы можете распечатать файл на экран с помощью cat ~/.ssh/id_rsa.pub и скопировать его вручную.
 Windows
 # скопировать содержимое ключа в буфер обмена:
 $ clip < ~/.ssh/id_rsa.pub
 # для ed25519:
 $ clip < ~/.ssh/id_ed25519.pub
  
 Если clip не сработает, выведите содержимое файла с помощью cat ~/.ssh/id_rsa.pub или cat ~/.ssh/id_ed25519.pub и скопируйте вывод в буфер обмена из консоли. 
Перейдите на GitHub и выберите пункт Settings (англ. «настройки») в меню аккаунта.
 

В меню слева нажмите на пункт SSH and GPG keys.
 

В открывшейся вкладке выберите New SSH key (англ. «новый SSH-ключ»).
 

В поле Title (англ. «заголовок») напишите название ключа. Например, Personal key (англ. «личный ключ»).
В поле Key type (англ. «тип ключа») должно быть Authentication Key (англ. «ключ аутентификации»).
В поле Key скопируйте ваш ключ из буфера обмена.
 

Нажмите на кнопку Add SSH key (англ. «добавить SSH-ключ»).
 

Проверьте правильность ключа с помощью следующей команды.
 $ ssh -T git@github.com
  
 Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение.
 The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?
  
 Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.
 Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub по этой ссылке. Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите yes, чтобы продолжить. Вы увидите приветствие на экране.
 Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.
  
Если у вас возникли сложности при генерации или привязке SSH-ключей, посмотрите видеоинструкцию, в которой мы показываем всё по порядку.

Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add (от англ. remote — «удалённый» и add — «добавить»).
$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория.
В командную строку нельзя вставить текст из буфера обмена с помощью привычного сочетания Ctrl+V. На Windows (в Git Bash) и Linux для этого используется сочетание Ctrl+Shift+V, а на macOS — Cmd+V.
Также можно нажать правую кнопку мыши и выбрать пункт Paste (англ. «вставить») в выпадающем меню.
origin (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.
Убедиться, что репозитории связаны, — git remote -v
Отлично: вы связали локальный репозиторий с удалённым. Осталось убедиться, что всё работает, с помощью следующей команды.
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push) 
В выводе вы должны увидеть две строчки, аналогичные тем, что показаны выше.
Флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.

Отправить изменения на удалённый репозиторий — git push
Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью git add, закоммитили их с комментарием командой git commit -m. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда git push (от англ. push — «толкать»).
В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории, так же и здесь нужно дополнительно связать ветки.
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master. 
Появится такой экран.

При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.
Если вы указывали кодовую фразу при настройке SSH-ключей, её нужно будет ввести.
Зайдите в репозиторий first-project на GitHub. Вы увидите, что в репозитории появились файлы с изменениями.

В дальнейшем при работе с удалённым репозиторием флаг -u можно опустить и писать просто git push.

Клонировать репозиторий — git clone
Откройте этот репозиторий. Нажмите на зелёную кнопку Code. Появится окно со ссылкой. Если вы уже настроили SSH-ключ, убедитесь что выбрана опция SSH и нажмите на кнопку с двумя квадратами справа — она скопирует ссылку в буфер обмена. Вы также можете скопировать ссылку вручную.

⚠️ Если вы не настраивали SSH-ключ, рекомендуем ещё раз заглянуть в урок об SSH и настроить его. Так работа с GitHub будет более безопасной.
Теперь откройте консоль, перейдите в папку, в которую хотите положить репозиторий, и выполните команду git clone (от англ. clone — «клон», «копия»). Она создаст копию удалённого репозитория на вашем компьютере. В качестве параметра команде нужно передать адрес репозитория, который вы только что скопировали на GitHub.
$ git clone https://github.com/yandex-praktikum/git-clone-lesson
# укажите адрес репозитория, который нужно склонировать 
Команда git clone автоматически связывает локальный и удалённый репозитории. То есть если в GitHub-репозитории что-то поменяется (например, добавятся коммиты), вам не нужно будет заново клонировать его. Достаточно будет выполнить команду, которая обновит вашу копию.
Убедитесь в том, что репозитории связаны, командой git remote -v.
$ cd git-clone-lesson
$ git remote -v
origin    git@github.com:yandex-praktikum/git-clone-lesson.git (fetch)
origin    git@github.com:yandex-praktikum/git-clone-lesson.git (push) 
Готово! Теперь на вашем компьютере есть копия удалённого репозитория.
Склонируйте этот репозиторий. С помощью команды cat выведите содержимое файла task.txt в консоль. Скопируйте содержимое в поле ниже.
Ваш ответ правильный
Страшный-престрашный секрет
Супер: вы успешно склонировали репозиторий и даже поработали с его содержимым!

Допустим, вы хотите усовершенствовать чужой проект или как-то использовать его в своей работе, но у вас нет прав на изменение оригинального репозитория. Разберём ещё одну полезную операцию копирования проектов. В отличие от клонирования, она не скачает репозиторий на локальный компьютер, но добавит его прямо в ваш аккаунт на сервере GitHub.
Что такое Fork
Fork (англ. «развилка», «ответвление»), или «форк», — это GitHub-операция; напрямую с Git она не связана. «Форк» создаёт копию репозитория в аккаунте GitHub. Такая копия будет полностью независима. Изменения, которые вы внесёте, не будут синхронизированы с исходным репозиторием.
В процессе «форка» создаётся копия всех файлов, истории коммитов и веток. Эта копия сохраняется в вашей учётной записи GitHub.
Вот некоторые из распространённых причин использования «форков»:
Вы хотите внести свой вклад в проект (например, open source), но не имеете прав на изменение исходного репозитория. Тогда вы можете сделать «форк», добавить нужные правки, а затем отправить запрос на включение этих изменений в оригинальный проект.
Вы хотите развивать проект независимо от исходного. Допустим, создатели проекта решили, что не будут добавлять функциональность, которая вам необходима. В таком случае вы можете сделать «форк» и добавить её самостоятельно.
Применяем «форк»
Потренируйтесь выполнять «форк». Перейдите по этой ссылке и нажмите на кнопку Fork в правом верхнем углу.

В открывшемся окне вы можете поменять название и описание репозитория. Или поставить галку, чтобы склонировать только главную ветку вместо всех сразу. Нажмите Create fork (англ. «создать копию репозитория»).

Немного подождите, пока репозиторий скопируется. После этого он будет доступен по адресу https://github.com/%USERNAME%/git-basics, где %USERNAME% — ваше имя пользователя.
В результате вы получите полную копию исходного репозитория, которую можно свободно изменять и которой можно управлять.
💡 Обычно комбинация «форк» + clone используется для внесения изменений в публичные репозитории. В этом случае «форк» становится подготовительным этапом перед клонированием чужого репозитория на ваш компьютер.
Если репозиторий приватный или это репозиторий вашей компании, при работе с ним достаточно clone.

Теперь внесите изменения в новый репозиторий. Для начала скопируйте его локально.
$ git clone git@github.com:%ВАШ_АККАУНТ%/git-basics.git
# укажите адрес репозитория 
Когда клонирование будет завершено, перейдите в локальный репозиторий командой cd. 
Создайте файл test.txt, добавьте в него несколько любых предложений и выполните коммит git commit -m "Первый коммит".
💡 Если ввести git commit без флага -m, откроется редактор Vim. Чтобы выйти из него, нажмите клавишу Esc, наберите последовательность символов :q! и нажмите Enter.
Отправьте изменения в удалённый репозиторий командой git push (от англ. push — «толкнуть», «протолкнуть»). Обратите внимание: вам не нужно указывать флаг -u origin main. Команда git clone сама свяжет удалённые и локальные ветки в момент клонирования.
Снова откройте браузер с GitHub и обновите страницу. Вы увидите опубликованные вами файл и коммит.


## .md

Преимущество README.md в том, что средства командной работы (такие, как GitHub) могут отображать его содержимое в браузере в виде удобной разметки. Для этого нужно не просто залить текст, но и настроить шрифт, заголовки и отступы с помощью markdown. Маркда́ун — это специальный язык разметки. Он позволяет красиво отформатировать текстовый документ.
Разберём базовый синтаксис этого языка. Все правила запоминать не нужно: при оформлении репозитория вы всегда можете вернуться к этому уроку.
Заголовки, абзацы и перенос
Заголовки разных уровней создают решётками.
  # H1 — заголовок первого уровня, самый большой
  ## H2 — заголовок второго уровня, поменьше
  ### H3
  #### H4
  ##### H5
  ###### H6 — заголовок шестого уровня, самый маленький
   
Можно добавить черту под заголовком или абзацем.
  #### Заголовок 4
  
  Текст над чертой
  
  ---
  
  Текст под чертой
   
Чтобы сделать разрыв строки, нужно поставить два пробела (в примере ниже они обозначены точками ⋅⋅) или сочетание символов <br>.
  
  Текст до переноса⋅⋅  
  Текст после переноса <br>
  Текст после второго переноса
   
Чтобы начать новый параграф, в конце предыдущей строки должно стоять два символа переноса. Для этого нужно нажать Enter два раза.
  line
  
  another line 
   
  Если сделать один перенос строки, как в примере ниже, и не поставить два пробела, текст сольётся в одну строку.
  line 
  another line
   
  Вот пример текста в файле README.md. 
  

  А вот отображение такого файла. 
  

Выделение текста
Чтобы выделить текст курсивом (текст), его заключают в звёздочки (астериски) или нижние подчёркивания.
  Курсив — это *звёздочки* или _подчёркивания_.
   
Чтобы выделить текст полужирным шрифтом (текст), его окружают двойными звёздочками или двойными нижними подчёркиваниями.
  Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.
  Можно совместить выделение **звёздочки и _подчёркивания_**.
   
Чтобы зачеркнуть текст (текст), его окружают двойными волнистыми линиями — тильдами.
  ~~Зачёркнутый текст.~~
   
Списки
Для оформления нумерованного списка достаточно поставить в начало строки цифры с точкой.
  1. Первый пункт нумерованного списка.
  2. Второй пункт.
   
Ненумерованный список создаётся звёздочкой с пробелом в начале строки либо дефисом с пробелом.
  * первый пункт ненумерованного списка;
  * второй пункт ненумерованного списка
  
  - первый пункт ненумерованного списка;
  - второй пункт ненумерованного списка
   
Ссылки
Чтобы сделать ссылкой часть текста, его заключают в квадратные скобки, а затем указывают нужный адрес в круглых скобках.
  [Яндекс](https://www.yandex.ru)
   
Также можно добавить ссылке тайтл (от англ title — «название», «заголовок»). Тайтл — это всплывающая подсказка, которая появляется при наведении мыши на ссылку. Тайтл нужно заключить в кавычки и указать внутри скобок после адреса.
  [Яндекс](https://www.yandex.ru "Я Yandex!")
   
Код
Чтобы оформить текст как код, нужно окружить его тройками косых кавычек — грависов. После первой тройки грависов указывают язык программирования, на котором написан код. В маркдауне есть поддержка синтаксиса почти всех популярных языков и инструментов.
```bash
ls - la
```
```html
<h1>А я просто текст</h1>
``` 
Обратите внимание: вторая тройка тройных кавычек стоит на отдельной строке.
Пример файла README.md
Если собрать всё вместе, файл README.md может выглядеть так.

# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```
Это лишь некоторые функции markdown.
 
 ---

 #Хеш, лог и HEAD

 В этом уроке вы изучите три важных понятия — все они помогут вам разобраться, как организована история коммитов. Вы узнаете, зачем нужен хеш, какая информация содержится в логе и как просмотреть краткую его версию, а также заглянете в файл HEAD.

 ##Хеш — идентификатор коммита
 В процессе работы с Git вам будет часто встречаться понятие «хеш коммита». Эти странные строчки с бессмысленным (на первый взгляд) набором букв и цифр вы могли видеть, когда вызывали команду git log и выводили историю коммитов.

 *Хеширование* (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).
 Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит. Git хеширует (преобразует) эту информацию с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.
 В то время, как результат работы метода hashCode() — это целое число, результат хеширования в Git — символьная строка. Она относительно коротка (40 символов в случае SHA-1) и состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). Хеш обладает следующими важными свойствами:
 если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый; если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

 Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.
 При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
 Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.

 ##Исследуем лог
 После вызова git log появляется список коммитов с их описанием.

 Вот из каких элементов состоит описание:
 Строка из цифр и латинских букв после слова commit — это уже знакомый вам хеш коммита.
 *Author* — имя автора и его электронная почта.
 *Date* — дата и время создания коммита.
 Сообщение к коммиту.
 Исходный код самого Git тоже хранится в Git-репозитории (тут уместно вспомнить про курицу и яйцо). Вот так выглядит описание первого коммита в репозитории Git. Изучите его.

 ```
 commit e83c5163316f89bfbde7d9ab23ca2e25604af290
 Author: Linus Torvalds <torvalds@linux-foundation.org>
 Date:   Thu Apr 7 15:13:13 2005 -0700

     Initial revision of "git", the information manager from hell
 ```

 Если в репозитории уже много коммитов — например, сотни или тысячи, — пригодится сокращённый лог. С ним можно быстро найти нужный коммит по описанию.
 Сокращённый лог вызывают командой git log с флагом --oneline (англ. «одной строкой»). При этом в терминале появятся только первые несколько символов хеша каждого коммита и комментарии к ним.

 Сокращённый хеш (первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

 ##HEAD — всему голова
 При вызове команды git log вы также могли заметить надпись (HEAD -> master) после хеша одного из коммитов.

 Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).
 Убедитесь в этом с помощью терминала. Перейдите в папку .git командой cd. Посмотрите содержимое файла HEAD командой cat.
 ```
 $ pwd # посмотрели, где мы
 /Users/user/dev/first-project
 ```
 ```
 $ cd .git/
 $ ls # посмотрели, какие есть файлы
 COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
 HEAD            config     hooks/       info/  objects/
 ```
 ```
 $ cat HEAD # команда cat показывает содержимое файла
 ref: refs/heads/master # в файле вот такая ссылка
 Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.
 $ cat refs/heads/master # взяли ссылку из файла HEAD
 # внутри хеш
 e007f5035f113f9abca78fe2149c593959da5eb7
 ```
 ```
 $ git log
 # сверяем с хешем последнего коммита
 commit e007f5035f113f9abca78fe2149c593959da5eb7
 Author: John Doe <johndoe@example.com>
 Date:   Tue Mar 28 00:26:53 2023 +0300

     Добавить амбиций в список дел
 ```

 ... # другие коммиты
 Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
 При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

 #Зачем нужны статусы файлов и как читать git status
 Частая ошибка при использовании Git — закоммитить лишнее или, наоборот, забыть добавить важный файл в коммит. Этого можно избежать, если не забывать проверять состояния (или статусы) файлов командой git status. В этом уроке разберём подробнее, в каких состояниях могут находиться файлы в репозитории и как читать вывод git status.

 ##Статусы untracked/tracked, staged и modified
 Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.
 untracked (англ. «неотслеживаемый»)

 *Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
 staged (англ. «подготовленный»)*

 После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

 *Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
 modified (англ. «изменённый»)*

 *Состояние modified значит, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.*

 Вот что ещё важно учесть:
 *Для файлов в состояниях staged и modified обычно не указывается, что они также tracked, потому что это состояние подразумевается.*
 Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging. Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.
 Типичный жизненный цикл файла в Git
 Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.

 *Файл только что создали. Git ещё не отслеживает его содержимое. Состояние: untracked.*

 *Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked).
  a. Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked).
  Обратите внимание: staged и modified у одного файла, но у разных его версий.
  b. Ещё раз выполнили git add. Состояние: staged (+ tracked).
 Сделали коммит с помощью git commit. Состояние: tracked.
 Изменили файл. Состояние: modified (+ tracked).
 Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).
 Сделали коммит. Состояния: tracked.
 Повторили пункты 4−7 много-много раз.*

 ##Какие состояния показывает команда git status
 Большинство файлов в типичном проекте будут находиться в состоянии tracked (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды git status — иначе она бы каждый раз выводила список вообще всех файлов проекта. В итоге git status показывает только следующие состояния файлов:
 *staged (Changes to be committed в выводе git status);
 modified (Changes not staged for commit);
 untracked (Untracked files).*

 Потренируйтесь читать вывод git status вместе с нами. Инициализируйте новый репозиторий ~/dev/git-status-lesson. Создайте в нём файл README.md и закоммитьте его.
 ```
 $ cd ~/dev
 $ mkdir git-status-lesson
 $ cd git-status-lesson
 $ git init
 # тут Git выведет что-нибудь, но мы это пропустим
 $ touch README.md
 $ git add README.md
 $ git commit -m 'Добавить README'
 # по традиции первым создадим и закоммитим файл README.md
 ```

 Дальше вы будете добавлять в репозиторий файлы и проверять их статусы. Мы рассмотрим четыре примера состояний, в которых может находиться ваш репозиторий.

 ###Нет ни staged-, ни modified-, ни untracked-файлов.
 Если ничего не менять в git-status-lesson после первого коммита, то в нём не должно быть ни изменённых файлов (modified), ни новых (untracked), ни добавленных в список на коммит (staged). Вызовите команду git status. Её вывод будет примерно таким.
 ```
 $ git status
 On branch master
 nothing to commit, working tree clean
 ```
 Это означает, что в репозитории нет новых или изменённых файлов. Последняя строка nothing to commit, working tree clean переводится как «нечего коммитить, рабочая директория чиста». Первая строка On branch master сообщает, что текущая ветка — master.

 ##Найдены неотслеживаемые файлы.
 Создайте в папке ~/dev/git-status-lesson файл fileA.txt. Теперь в репозитории есть новый файл в состоянии untracked. Снова вызовите команду git status. Результат будет таким.
 ```
 $ touch fileA.txt
 $ git status
 On branch master
 Untracked files: # найдены неотслеживаемые файлы
   (use "git add <file>..." to include in what will be committed)
         fileA.txt

 nothing added to commit but untracked files present (use "git add" to track)
 ```

 Файл fileA.txt отображается в секции неотслеживаемых файлов — Untracked files. Это значит, что он не был добавлен в репозиторий через git add.
 В выводе git status есть подсказка, какую команду использовать, чтобы добавить файл в список на коммит: Use git add <file> to include in what will be committed (англ. «используйте git add <file>, чтобы добавить в список на коммит»). Добавьте fileA.txt в staging area с помощью git add и снова запросите git status.
 ```
 $ git add fileA.txt
 $ git status
 On branch master
 Changes to be committed: # новая секция
   (use "git restore --staged <file>..." to unstage)
         new file:   fileA.txt
 ```

 Теперь fileA.txt находится в секции Changes to be committed (англ. «изменения, которые попадут в коммит»). Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.
 ```
 $ git commit -m 'Добавить файл fileA.txt'
 # тут будет вывод комманды commit, он нас не интересует
 $ git status
 On branch master
 nothing to commit, working tree clean
 ```
 Вывод команды git status такой же, какой был после первого коммита: «Директория чиста».
 Найдены изменения, которые не войдут в коммит
 Теперь откройте файл fileA.txt и добавьте в него несколько слов — например, Это файл A!. Сохраните fileA.txt и вызовите команду git status. Её результат будет такой.
 # внесли в fileA.txt правки
 # запросили статус
 ```
 $ git status
 On branch master
 Changes not staged for commit: # ещё одна секция
   (use "git add <file>..." to update what will be committed)
   (use "git restore <file>..." to discard changes in working directory)
         modified:   fileA.txt
 ```
 Файл fileA.txt был изменён, но не добавлен в staging area после этого. Так он оказался в секции Changes not staged for commit (англ. «изменения, которые не подготовлены к коммиту»), соответствующей статусу modified. Подготовьте правки к коммиту через git add.
 ```
 $ git add fileA.txt
 $ git status
 On branch master
 Changes to be committed: # все изменения готовы к коммиту
   (use "git restore --staged <file>..." to unstage)
         modified:   fileA.txt
 ```

 Теперь в коммит попадёт уже новая версия файла fileA.txt. Обратите внимание: хотя вывод команды git status похож на тот, что был после первого добавления файла fileA.txt, они отличаются. Когда новый файл попадает в staging area, перед его названием указывается new file: new file: fileA.txt. Если файл уже однажды попадал в историю (с помощью коммита) и был изменён, после выполнения git add он будет записан уже так: modified: fileA.txt.
 Файл добавлен в staging area, но после этого изменён
 Вы добавили файл в staging area, но перед коммитом вспомнили нечто важное. Например, вместо одного восклицательного знака в конце строки Это файл A! нужно поставить три.
 Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать git status. Он покажет следующее.
 ```
 # изменили fileA.txt
 $ git status
 On branch master
 Changes to be committed:
   (use "git restore --staged <file>..." to unstage)
           modified:   fileA.txt

 Changes not staged for commit:
   (use "git add <file>..." to update what will be committed)
   (use "git restore <file>..." to discard changes in working directory)
           modified:   fileA.txt
 ```

 Файл попал и в staged (Changes to be committed), и в modified (Changes not staged for commit). В staging area находится версия файла с одним восклицательным знаком, а в Changes not staged for commit — уже изменённая версия, с тремя. Чтобы закоммитить самую свежую версию файла, нужно снова выполнить git add перед коммитом. Готово!

 #Оформление сообщений к коммитам
 То, как написаны сообщения к коммитам, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями. Например, в выводе команды git log --oneline умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».
 В этом уроке рассмотрим несколько популярных подходов к оформлению сообщений коммитов. Но сначала разберём, почему такие сообщения важны и зачем соблюдать правила их оформления.

 ##Зачем вообще писать сообщения
 У каждого коммита в Git есть сообщение — то, что передаётся после параметра -m. Например: git commit -m "Добавить урок про оформление сообщений коммитов".
 Сообщения коммитов можно сравнить с надписями на коробках в кладовке. Если надписей нет, то нужную коробку будет сложно найти: придётся заглянуть в каждую, чтобы понять, что там. А если надписи есть, то нужная найдётся сразу.
 Как и надпись на коробке, сообщение коммита должно помочь определить, что внутри. Например, надпись на коробке «всякое разное» не очень полезная. Сообщение коммита «небольшие исправления» тоже: непонятно, что было исправлено в таком коммите и зачем.
 Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:
 относительно коротким, чтобы его было легко прочитать;
 информативным.

 Вот пример полезного сообщения в репозитории новостного сайта: Исправление опечатки в заголовке главной страницы на хорватском. Такое сообщение даёт много информации:
 Исправление опечатки значит, что исправлена ошибка, которая была допущена при наборе. Такое исправление не меняет смысл. То есть, например, главному редактору не нужно перепроверять этот заголовок.
 На хорватском говорит о том, что переводчикам на другие языки этот коммит можно смело пропускать.
 В заголовке главной страницы указывает, где произошли изменения. Если, например, кто-то зайдёт на сайт и ему не понравится новый заголовок, он легко найдёт по истории (git log) автора этого коммита и спросит у него, почему заголовок теперь такой.
 Пример плохого сообщения для того же коммита: Исправлена опечатка. Это сообщение даёт мало информации. В такой коммит придётся «заглядывать» — разбираться, что именно поменялось и зачем.

 ##Стили оформления
 Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: Исправить сообщение об ошибке E123, кто-то — глаголы в прошедшем времени: Исправил…, кто-то — существительные: Исправление….
 Без единообразия коммитов нет и эффективной работы в Git. Это может показаться мелочью, но когда коммиты с сообщениями в разных стилях идут друг за другом, их может быть сложно читать.
 Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.
 Например, правила могут быть такие:
 длина сообщения от 30 до 72 символов;
 первое слово — глагол в инфинитиве («исправить», «дополнить», «добавить» и другие);
 и так далее.
 Есть много подходов к оформлению сообщений коммитов, но мы расскажем о нескольких популярных. Их используют как отдельные команды, так и целые проекты.

 ##Корпоративный
 Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это 239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).
 В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.
 ```
 $ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"
 ```
 Какие-то команды могут договариваться, с какой части речи начинать сообщение и какой длины оно должно быть, какие-то — нет. Но требование о наличии Jira-ID обычно строгое: оно позволяет автоматически связывать коммиты с задачами и проектами.

 ##Conventional Commits
 Стандарт Conventional Commits (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. А вот использовать его для других типов проектов было бы неудобно.
 Conventional Commits предлагает такой формат коммита: <type>: <сообщение>. Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:
 feat (сокращение от англ. feature) — для новой функциональности;
 fix (от англ. «исправить», «устранить») — для исправленных ошибок.
 Более подробный список можно увидеть на сайте с описанием этого стиля.
 Например, сообщение может быть таким.
 git commit -m "feat: добавить подсчёт суммы заказов за неделю"
 GitHub-стиль
 GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так.
 ```
 $ git commit -m "Исправить #334, добавить график температуры"
 ```
 В таком случае GitHub свяжет коммит и задачу.
